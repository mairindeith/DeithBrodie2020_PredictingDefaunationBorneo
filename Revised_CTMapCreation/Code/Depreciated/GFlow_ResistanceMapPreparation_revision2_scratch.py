#------------------------
# Code to create a resistance surface from standardized files
#     for the Malaysian states of Borneo
#
# This script uses maps created with 'MSYBorneo_ResistanceMapLayers_Preparation.py'
# Created by Mairin Deith on Nov12 2017
# Last edited for revised mapping effort on Jul4 2019
#------------------------
# Hierarcy of resistance values:
#   Walking speed - modified by land cover type (incl. plantations) and slope
#       - presumed maximum at ideal slope is 6kph
#   Roadways - logging roads have a max speed of 20kph, major roads 60 kph
#   Rivers - passable rivers (Strahler order <3), navigable rivers (Strahler order > 5 is navigable at 20kph)

#!/usr/bin/env python

# Import libraries
import numpy as np
import gdal # for opening files as np arrays
import gc
import os, sys
import math
from pathlib import Path
import codecs

# Global parameters
output_path = Path('/home/mairin/Documents/GradSchool/Research/CircuitTheory_Borneo/PRSB_Revision2/Revised_CTMap/ResistanceMap')
input_path = output_path / 'ModifiedSpatialData'
global_nodata = -9999

def main():
    print('--- Begin ---')
    mod_pixel_size = 1 # This ensures that GFlow can read the data properly
    ### Locations of standardized rasters (in increasing order of influence on resistance)
    fc_loc = input_path / 'REGIONBorneo_FCDefDeg_1973to2010_CIFOR_clipped_rs.tif'
    plantation_loc = input_path / 'GaveauPlantationClip_raster.tif'
    slope_loc = input_path / 'RDSlope.tif'
    strahler_loc = input_path / 'StrahlerOrder_rs.tif'
    road_loc = input_path / 'rasterizedRoads.tif'
    ### LOAD RASTERS AND FIX NAs WHERE THEY ARE NOT GLOBALLY NAN
    with rio.open(str(plantation_loc), 'r') as ds:
        plantation = ds.read()
    plantation[plantation == 0] = global_nodata
    # Start with an empty array and fill with values
    # First load in the road array
    
    # This works, ReadAsArray() from GDAL does not
with rio.open(str(fc_loc), 'r') as ds:
    fc_arr = ds.read()  # read all raster values

with rio.open(str(slope_loc), 'r') as ds:
    slope_arr = ds.read()  # read all raster values

resist_array = np.empty(fc_arr.shape)
resist_array[:] = np.nan
    
# First, all NaN values in slope set to zero     


    
    resist_array[road_arr==1] = 60 # Major roads are coded as 1
    resist_array[road_arr==2] = 20 # Logging roads are coded as 2
        
	slope = np.array(gdal.Open(str(slope_loc)).GetRasterBand(1).ReadAsArray())
	land = np.array(gdal.Open(str(fc_resample_loc)).GetRasterBand(1).ReadAsArray())
#	print("Slope array: " + str(slope_array.shape))
#		print("River array: " + str(river_array.shape))
#		print("Road array: " + str(road_array.shape))

	slope_array = np.array(slopeRaster.GetRasterBand(1).ReadAsArray())
	na_slope = slopeRaster.GetRasterBand(1).GetNoDataValue()

	# Drop the heavy file:
	slopeRaster = None
	print("Slope array: " + str(slope_array.shape))

### NOTE: Slope generated by GDAL's gdaldem function, slope expressed as % (but as whole percent, not decimal)
### Slope function stems from Tobler's walking velocity function: W = 6e^(-3.5*(dH/dX + 0.05))
		print('~~~~~~~~Modifying landuse with elevation')
		for i in range(0, landuse_speed.shape[0]):
			# Visual ticker of progress in %
			percent_comp = ((i*1.0)/landuse_speed.shape[0])*100.0
			if(percent_comp%2==0):
				print(".")
			if(percent_comp%10==0):
				print(str(percent_comp)+str("%"))
			for j in range(0, landuse_speed.shape[1]):
				if(landuse_o[i,j]==na_landuse or landuse_o[i,j]==5 or slope_array[i,j]):
					landuse_speed[i,j] = -999
					continue
						# Skip the NAs and cloud covered DEM areas, maximize at 200 as slope
				if(slope_array[i,j]==-9999 or slope_array[i,j]==0 or slope_array[i,j] > 200):
					if(landuse_o[i,j]==1):
						landuse_speed[i,j] = 1.0
					elif(landuse_o[i,j]==2):
						landuse_speed[i,j] = 1.25
					elif(landuse_o[i,j]==3):
						landuse_speed[i,j] = 2.0
					elif(landuse_o[i,j]==4):
						landuse_speed[i,j] = 30.0
					else:
						landuse_speed[i,j] = -999
					print('Empty array %s, %s' %(i,j))
				elif(slope_array[i,j]<1000): # There are weird cloud data still in the slope dataset
					modifier = float(math.exp(-3.5*((slope_array[i,j]/100.0)+0.05)))
					if modifier==0.0:
						print('ZERO ALERT! Modifier = 0, slope %s' %slope_array[i,j])

					if(landuse_o[i,j])==1:
						landuse_speed[i,j] = float(1.0*modifier)
					elif(landuse_o[i,j]==2):
						landuse_speed[i,j] = float(1.25*modifier)
					elif(landuse_o[i,j]==3):
						landuse_speed[i,j] = float(2.0*modifier)
						if(i==0 and j==17):
							print('LS is:' + str(landuse_speed[i,j]))
							print(str(modifier))
							print(str(landuse_o[i,j]))
							print(str(float(2.0*modifier)))
					elif(landuse_o[i,j]==4):
						landuse_speed[i,j] = 30.0
					else:
						landuse_speed[i,j] = 15.0
					if(float(landuse_speed[i,j])<0):
						print('NEGATIVE ALERT! Modifier: %s, Base: %s (is readable? %s)' %(modifier, landuse_o[i,j], landuse_o[i,j]==3))
						print('ZERO ALERT! Modifier * base = %s' %(2.0*modifier))
						sys.exit('%s, %s\nSlope: %s\nLanduse:%s' %(i,j,slope_array[i,j], landuse_o[i,j]))
		# Drop the heavy file:
		slope_array = None

		print('Creating walking speed output')
		speed_map_out = '/home/mairin/deithvader/Documents/UBC/MScThesis/ResistanceData/EditedMapFiles/Testing/WalkingSlopes'

#		geotransform=

		output_raster = gdal.GetDriverByName('GTiff').Create(str(speed_map_out+".tif"),landuse_speed.shape[1], landuse_speed.shape[0],1,gdal.GDT_Float32)  # Open the file
		output_raster.SetGeoTransform(geotransform) # Specify its coordinates
		srs = osr.SpatialReference()              	# Establish its coordinate encoding
		srs.ImportFromEPSG(4326)                    # This one specifies WGS84 lat long.

		output_raster.SetProjection(srs.ExportToWkt())   # Exports the coordinate system
		                                                   # to the file
		output_raster.GetRasterBand(1).WriteArray(landuse_speed)   # Writes my array to the raster

		# Modify landscape with rivers generated from DEM
		riverRaster = gdal.Open(strahler_loc)
		river_array = np.array(riverRaster.GetRasterBand(1).ReadAsArray())
		na_river = riverRaster.GetRasterBand(1).GetNoDataValue()
		riverRaster = None

		print('~~~~~~~~Adding rivers')
		for i in range(0, landuse_speed.shape[0]):
            # Progress counter
			percent_comp = (i*1.0)/landuse_speed.shape[0]*100.0
			if(percent_comp%2==0):
				print".",
			if(percent_comp%10==0):
				print(str(percent_comp)+str("%"))

			for j in range(0, landuse_speed.shape[1]):
				if(river_array[i,j] == 0 or river_array[i,j]==na_river):
					continue
				elif(river_array[i,j] == 3 or river_array[i,j] == 4):
					landuse_speed[i,j] = -999
				elif(river_array[i,j] > 5 and river_array[i,j] < 20):
					landuse_speed[i,j] = 20
				else:
					continue

				# if(landuse_speed[i,j] < 0.0000001):
				#	print('SMALL ALERT!' + str(i) + str(j) + '+' + str(landuse_speed[i,j]))

		# Drop the heavy file
		river_array = None

		print('Creating river speed output')
		speed_map_out = '/home/mairin/deithvader/Documents/UBC/MScThesis/ResistanceData/EditedMapFiles/Testing/RiverSpeeds'

		output_raster = gdal.GetDriverByName('GTiff').Create(str(speed_map_out+".tif"),landuse_speed.shape[1], landuse_speed.shape[0],1,gdal.GDT_Float32)  # Open the file
		output_raster.SetGeoTransform(geotransform) # Specify its coordinates
		srs = osr.SpatialReference()              	# Establish its coordinate encoding
		srs.ImportFromEPSG(4326)                    # This one specifies WGS84 lat long.

		output_raster.SetProjection(srs.ExportToWkt())   # Exports the coordinate system
		                                                   # to the file
		output_raster.GetRasterBand(1).WriteArray(landuse_speed)   # Writes my array to the raster


		# Final modification: overlay roads, these trump all other speeds
		roadRaster = gdal.Open(mergedRoad_loc)
		road_array = np.array(roadRaster.GetRasterBand(1).ReadAsArray())
		na_road = roadRaster.GetRasterBand(1).GetNoDataValue()

		# Drop the heavy file:
		roadRaster = None

		print('~~~~~~~~Overlaying roads')
		for i in range(0, landuse_speed.shape[0]):
			percent_comp = (i*1.0)/landuse_speed.shape[0]*100.0
			if(percent_comp%2==0):
				print".",
			if(percent_comp%10==0):
				print(str(percent_comp)+str("%"))
			for j in range(0, landuse_speed.shape[1]):
				# Roads are the strongest speed modifier
				if(road_array[i,j]==na_road):
					continue
				elif(road_array[i,j]==1):
					# Major roads, 60km/h
					landuse_speed[i,j] = 60
					continue
				elif(road_array[i,j]==2):
					# Logging roads, 10km/h
					landuse_speed[i,j] = 10
				else:
					continue


		# Drop the heavy file:
		road_array = None

		print('Converting speeds to resistances')

		resistance = np.empty(landuse_o.shape, dtype=float)

		for i in range(0, landuse_speed.shape[0]):
			for j in range(0, landuse_speed.shape[1]):
#				No values should be zero, negative, or greater than 60km/h
				if(landuse_speed[i,j]<=0 or landuse_speed[i,j]>60):
					resistance[i,j] = -999
				elif(landuse_speed[i,j]>=0.01 and landuse_speed[i,j]<=60):
					resistance[i,j] = 1/landuse_speed[i,j]

		print('Creating final speed output')

		speed_map_out = outpath+'speed_map_out'
		resistance_map_out = outpath+'resistance_map_out'

# Procedure to create a geospatially explicit Tiff output (from http://gis.stackexchange.com/questions/37238/writing-numpy-array-to-raster-file)
		geotransform=(x_ll,pixel_size,0,y_ul,0, -pixel_size)
		# That's (top left x, w-e pixel resolution, rotation (0 if North is up),
		#         top left y, rotation (0 if North is up), n-s pixel resolution)


# Save raster for speed (ASCII):
		print("Saving final image for Q%s" %q)
		np.savetxt(str(speed_map_out+'.asc'), landuse_speed, delimiter=' ', newline='\n', comments='',
			header=("NCOLS "+str(landuse_speed.shape[1])+"\n"+
				"NROWS "+str(landuse_speed.shape[0])+"\n"+
				"XLL CORNER %s\nYLL CORNER %s\nCELLSIZE %s\nNODATA_value -999" %(x_ll, y_ll, pixel_size)))

# Save raster for resistance (ASCII):
		print("Saving final image for Q%s" %q)
		np.savetxt(str(resistance_map_out+'.asc'), resistance, delimiter=' ', newline='\n', comments='',
			header=("NCOLS "+str(resistance.shape[1])+"\n"+
				"NROWS "+str(resistance.shape[0])+"\n"+
				"XLL CORNER %s\nYLL CORNER %s\nCELLSIZE %s\nNODATA_value -999" %(x_ll, y_ll, pixel_size)))

if __name__ == "__main__":
    main()

#### Old unused functions:


#def cropRaster(base_raster, polygon):
#	# Takes in the paths of the raster to be modified and the shapefile to be used as a cropping template
#	(in_path, in_name) = os.path.split(base_raster)
#	short_in_name = in_name[0:len(in_name)-4]
#	out_name = str(short_in_name + '_cropped.tif')
#	os.system('gdalwarp -cutline %s -crop_to_cutline %s %s/%s -overwrite' %(polygon, base_raster, modified_path, out_name))
#	return str(modified_path + '/' + out_name)
